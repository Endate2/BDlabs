#### Первый запрос
```sql
SELECT 
    Н_ТИПЫ_ВЕДОМОСТЕЙ.ИД, 
    Н_ВЕДОМОСТИ.ИД
FROM 
    Н_ТИПЫ_ВЕДОМОСТЕЙ
LEFT JOIN 
    Н_ВЕДОМОСТИ ON Н_ТИПЫ_ВЕДОМОСТЕЙ.ИД = Н_ВЕДОМОСТИ.ТВ_ИД
WHERE 
    Н_ТИПЫ_ВЕДОМОСТЕЙ.ИД > 1
    AND Н_ВЕДОМОСТИ.ДАТА > '2010-06-18';
```

![первого запроса](https://github.com/Endate2/BDlabs/blob/main/%D0%BB%D0%B0%D0%B1%D1%8B%20%D0%B1%D0%B4/%D0%BB%D0%B0%D0%B1%D0%B0%204/%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%201%20%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%201.png)

![первого запроса](https://github.com/Endate2/BDlabs/blob/main/%D0%BB%D0%B0%D0%B1%D1%8B%20%D0%B1%D0%B4/%D0%BB%D0%B0%D0%B1%D0%B0%204/%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%201%20%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%202.png)

![первого запроса](https://github.com/Endate2/BDlabs/blob/main/%D0%BB%D0%B0%D0%B1%D1%8B%20%D0%B1%D0%B4/%D0%BB%D0%B0%D0%B1%D0%B0%204/%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%201%20%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%203%20.png)

Оптимальным выполнением запроса будет второй так как в нем происходит соединение таблиц которые уже прошли условие запроса.

Индексы:

```sql
CREATE INDEX idx_типы_ведомостей_ид ON "Н_ТИПЫ_ВЕДОМОСТЕЙ" ("ИД");
CREATE INDEX idx_ведомости_дата_full ON "Н_ВЕДОМОСТИ" ("ДАТА");
CREATE INDEX idx_ведомости_тв_ид ON "Н_ВЕДОМОСТИ" USING HASH ("ТВ_ИД");
```
Так как в задании используется выборка по диапозону значений, то лучше всего сюда подойдет индекс типа btree(дерево спускается по веткам на
основе сравнений, и работает за log(глубина), а обычный поиск за линейное время)
Добавление таких индексов должно ускорить выполнение запроса так как по ним идет выборка с оператором сравнения.

НО ТАК КАК В ТАБЛИЦЕ Н_ТИПЫ_ВЕДОМОСТЕЙ очень мало данных (всего 3 строки, из которых 2 подходят под условие). Для таких маленьких таблиц PostgreSQL предпочитает полное сканирование, поэтому его использование не нужно(только есл будет больше данных)

Система также не использовала индекс idx_ведомости_тв_ид, так как таблица Н_ТИПЫ_ВЕДОМОСТЕЙ очень маленькая и предпочла выполнить Hash join.

Выполнение команды `EXPLAIN ANALYSE`:
![первого запроса](https://github.com/Endate2/BDlabs/blob/main/%D0%BB%D0%B0%D0%B1%D1%8B%20%D0%B1%D0%B4/%D0%BB%D0%B0%D0%B1%D0%B0%204/%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%20explain%201.png)

Выполнение команды `EXPLAIN ANALYSE` до индексов:
![первого запроса](https://github.com/Endate2/BDlabs/blob/main/%D0%BB%D0%B0%D0%B1%D1%8B%20%D0%B1%D0%B4/%D0%BB%D0%B0%D0%B1%D0%B0%204/%D0%B4%D0%BE%20explain%201.png)
#### Второй запрос
```sql

SELECT 
    Н_ЛЮДИ.ИД, 
    Н_ОБУЧЕНИЯ.ЧЛВК_ИД, 
    Н_УЧЕНИКИ.НАЧАЛО
FROM 
    Н_ЛЮДИ
INNER JOIN 
    Н_ОБУЧЕНИЯ ON Н_ЛЮДИ.ИД = Н_ОБУЧЕНИЯ.ЧЛВК_ИД
INNER JOIN 
    Н_УЧЕНИКИ ON Н_УЧЕНИКИ.ЧЛВК_ИД = Н_ОБУЧЕНИЯ.ЧЛВК_ИД
WHERE 
    Н_ЛЮДИ.ФАМИЛИЯ < 'Иванов'
    AND Н_ОБУЧЕНИЯ.НЗК = '001000'
    AND Н_УЧЕНИКИ.ИД > 100410;
```
Первый вавриант выполнения
![второго запроса](https://github.com/Endate2/BDlabs/blob/main/%D0%BB%D0%B0%D0%B1%D1%8B%20%D0%B1%D0%B4/%D0%BB%D0%B0%D0%B1%D0%B0%204/%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%202%20%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%201.png)
Второй вавриант выполнения
![второго запроса](https://github.com/Endate2/BDlabs/blob/main/%D0%BB%D0%B0%D0%B1%D1%8B%20%D0%B1%D0%B4/%D0%BB%D0%B0%D0%B1%D0%B0%204/%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%202%20%D0%B2%D1%8B%D0%BF%D0%BE%D0%BB%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5%202.png)

Первый план точно самый неоптимальный, так как там все сравнения и уменьшения
выборки происходят после объединений. Во втором мы сразу перед первым Inner join делаем выборку и уменьшаем
множество для объединения.
Индексы:

```sql
CREATE INDEX idx_обучения_нзк_hash ON Н_ОБУЧЕНИЯ USING hash (НЗК);
CREATE INDEX idx_обучения_члвк_ид_hash ON Н_ОБУЧЕНИЯ USING hash (ЧЛВК_ИД);
CREATE INDEX idx_люди_фамилия ON Н_ЛЮДИ USING btree (ФАМИЛИЯ);
CREATE INDEX idx_ученики_ид ON Н_УЧЕНИКИ USING btree (ИД);
```

Пойдемся по каждому из индексов:
1)Стоит добавть hash(хеширует значение идет по
этому ключу, таким образом время исполнения - амортизированная константа) так как есть четкое условие Н.ОБУЧЕНИЯ.НЗК = 001000 
Он будет идельно работать для четких условий.
2)Втой hash идекс поможет, так как ускоряет равенство JOIN - INNER JOIN Н_ОБУЧЕНИЯ ON Н_ЛЮДИ.ИД = Н_ОБУЧЕНИЯ.ЧЛВК_ИД
3)На Н.ЛЮДИ.ФАМИЛИЯ имеет смысл добавить индекс B-TREE (дерево спускается по веткам на
основе сравнений, и работает за log(глубина), а обычный поиск за линейное время), так как используется >
4)Аналагично 3 

Выполнение команды `EXPLAIN ANALYSE` до индексов:
![Второго запроса](https://github.com/Endate2/BDlabs/blob/main/%D0%BB%D0%B0%D0%B1%D1%8B%20%D0%B1%D0%B4/%D0%BB%D0%B0%D0%B1%D0%B0%204/%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%202%20%D0%B4%D0%BE%20%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%BE%D0%B2.png)

Выполнение команды `EXPLAIN ANALYSE`:
![Второго запроса](https://github.com/Endate2/BDlabs/blob/main/%D0%BB%D0%B0%D0%B1%D1%8B%20%D0%B1%D0%B4/%D0%BB%D0%B0%D0%B1%D0%B0%204/%D0%B7%D0%B0%D0%BF%D1%80%D0%BE%D1%81%202%20%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%20%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%BE%D0%B2%20.png)
